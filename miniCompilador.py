# Programa "compilador" para generar Stored Procedures a partir de las tablas de una Base de Datos

import datetime
import os
import shutil

# Change it base on the name of the project
projectName= "ADA"
fileCounter=1
dataBaseFileLocation= "C:\\Users\\echav\\Documents\\ADA Emprendimiento\\Tech\\2. Código de Generación de Base de Datos\\ADA DATABASE.sql"
dataBaseName= "ADADB"


# Depends of the language, the standard output will be Prefix+TableName
creationPrefixSP = "MSP_Registrar" #Could be changed for register or create
editionPrefixSP = "MSP_Modificar" #Could be Modify
enablePrefixSP = "MSP_Habilitar" #Could be enable
disablePrefixSP = "MSP_Deshabilitar" # Could be disable
getPrefixSP = "MSP_Obtener" # Could be get
byIdPrefixSP = "PorId" # Could be byId
getEnabledSufixSP = "Habilitados"
getDisabledSufixSP = "Desabilitados"

enableColumn = "habilitado BIT" # Name of the standard name of enable in any table and the data type (i implemented as BIT)
# 0 = Disabled, 1 = Enabled. 

############################################################################################################################################# 
z="\n-- -----------------------------------------------------\n-- Table `MyProject`.`Habilidad`\n-- -----------------------------------------------------\nCREATE TABLE IF NOT EXISTS `ADADB`.`Habilidad` (\n  `idHabilidad` MEDIUMINT UNSIGNED NOT NULL AUTO_INCREMENT,\n  `idCategoriaHabilidad` SMALLINT UNSIGNED NOT NULL,\n  `nombreHabilidad` NVARCHAR(45) NOT NULL,\n  `descripcionHabilidad` NVARCHAR(450) NOT NULL,\n  PRIMARY KEY (`idHabilidad`, `idCategoriaHabilidad`),\n  INDEX `fk_Habilidad_CategoriaHabilidad1_idx` (`idCategoriaHabilidad` ASC),\n  UNIQUE INDEX `idHabilidad_UNIQUE` (`idHabilidad` ASC),\n  CONSTRAINT `fk_Habilidad_CategoriaHabilidad1`\n    FOREIGN KEY (`idCategoriaHabilidad`)\n    REFERENCES `ADADB`.`CategoriaHabilidad` (`idCategoriaHabilidad`)\n    ON DELETE NO ACTION\n    ON UPDATE NO ACTION)\nENGINE = InnoDB;"

# Input: Todo el código de una tabla MySQL generada con el Workbench | All the code of a table on mySQL generated by Workbench.

def getTableInfo(code):
       respuesta=[]
       omitir=["SET","PRIMARY","INDEX","UNIQUE","CONSTRAINT","FOREIGN",
               "REFERENCES","ON","ENGINE", "--"]
       omitir2=["NOT","NULL","NULL,"]
       lines= code.split("\n")
       primary=[]
       for line in lines:
              lineTemp = line
              line=line.split()
              fase=0
              omit=False
              columnaDato=""
              notNull=False
              for element in line:
                     if(element=="PRIMARY"):
                            primary=line
                            break
                     if(element in omitir):
                            break
                     elif(element=="CREATE"):
                            omit = True
                     elif(element[0:9] == "`ADADB`.`" and omit==True):
                            respuesta=respuesta+[element[9:-1]]
                            respuesta = respuesta + [[]] + [[]] + [[]]
                            #print (respuesta)
                            omit=False
                            break
                     elif(omit):
                            continue
                     else: # Esto es un punto dónde sólo entramos, luego del create. 
                            #print("LINEA \t: "+str(line))
                            #print("ELEMENT \t: "+str(element))
                            #print("ColumnaDato \t: "+str(columnaDato))
                            #print("Respuesta \t: "+str(respuesta))
                            #print()
                            if(fase>0 and line[-1]==element and element=="AUTO_INCREMENT,"): # Si encontramos un auto_increment, ignoramos toda la columna
                                   respuesta[3]=respuesta[3]+[columnaDato]
                                   break
                            elif(fase==0): # Luego del create, sólo corregimos un char y listo.
                                   columnaDato=element[1:-1]
                                   fase+=1
                            elif(fase>0 and line[-1]!=element):
                                   if element not in omitir2: # Si no es prohibida, la concatenamos en columnaDato
                                          columnaDato=columnaDato+" "+element
                                   else: # Si está en omitir2 y no es la última, es NOT (por ende valor fijo [1], y no opcional [2])
                                          notNull=True
                            else:
                                   if (element not in omitir2): # Básicamente si es null, lo ignoramos. 
                                          columnaDato=columnaDato+" "+element
                                   if(notNull):
                                          respuesta[1]=respuesta[1]+[columnaDato]
                                   else:
                                          respuesta[2]=respuesta[2]+[columnaDato]
       # Una vez que analizamos todo, generamos la data relacionada con las llaves primarias (que servirán para el editar)
       if primary!=[]:
              primary=primary[2:]
              primary[0].split(" ")
              primary[0]=primary[0][1:]
              for i in range(len(primary)):
                     primary[i]=primary[i][1:-2]
              primary[-1]=primary[-1][:-1]
              for values in respuesta[1]:
                     if values.split(" ")[0] in primary:
                            respuesta[3]= respuesta[3] + [values]
              
       return(respuesta)


# Display's getTableInfo nicely. 
def printTableInfo(resultado):
       print("\nNombre de la Tabla: "+resultado[0])
       print("Columnas Fijas: ")
       for values in resultado[1]:
              print("\t"+str(values))
       print("Columnas Opcionales: ")
       for values in resultado[2]:
              print("\t"+str(values))
       print("Columnas Primarias: ")
       for values in resultado[3]:
              print("\t"+str(values))
       
# Create a Register stored procedure, based on the output of getTableInfo
def registerTable(tableData):
       #print (tableData)
       respuesta= "\n\n\nDELIMITER //\n"
       respuesta+="/* --------------------------------------------------------------\n"
       respuesta+="\tCreado por:\tEduardo Andrés Chavarría Rey\n"
       respuesta+="\tFecha y Hora de Creación:\t"+str(datetime.datetime.now())[0:-7]+"\n"
       respuesta+="\tProcedimiento almacenado encargado de insertar un registro en "+tableData[0]+"\n"
       respuesta+="   --------------------------------------------------------------\n"
       respuesta+="*/\n"
       respuesta+="CREATE PROCEDURE "+creationPrefixSP+tableData[0]+"("
       flagNombre=[]
       for values in tableData[1]:
              #print(values)
              respuesta+="\n\tp"+values[0].upper()+values[1:]+","
              if (values[0:6]=="nombre"):
                     flagNombre+=[values]
       respuesta=respuesta[0:-1]+"\n)\n"
       respuesta+="\tBEGIN\n"
       #for values in tableData[2]:
       if(flagNombre != []):
              for values in flagNombre:
                     respuesta+="\t\tDECLARE v"+values[0].upper()+values[1:]+";\n"
       respuesta+="\n\t\tDECLARE EXIT HANDLER FOR SQLEXCEPTION -- ERROR"
       respuesta+="\n\t\tBEGIN"
       respuesta+="\n\t\t\tSELECT -1;"
       respuesta+="\n\t\t\tRESIGNAL;"
       respuesta+="\n\t\t\tROLLBACK;"
       respuesta+="\n\t\tEND;\n\n"
       contador=2
       if(flagNombre != []):
              
              for values in flagNombre:
                     respuesta+="\t"*contador+"SELECT "+values.split()[0]+" FROM "+tableData[0]+"\n"
                     respuesta+="\t"*contador+"WHERE "+values.split()[0]+"="+"p"+values.split()[0][0].upper()+values.split()[0][1:]+"\n"
                     respuesta+="\t"*contador+"LIMIT 1 INTO v"+values.split()[0][0].upper()+values.split()[0][1:]+";\n\n"
                     respuesta+="\t"*contador+"IF(v"+values.split()[0][0].upper()+values.split()[0][1:]+" IS NOT NULL)\n"
                     respuesta+="\t"*contador+"THEN\n\n"
                     respuesta+="\t"*(contador+1)+"SELECT "+str(-contador)+";\n\n"
                     respuesta+="\t"*contador+"ELSE \n\n"
                     contador+=1

       respuesta+="\t"*(contador)+"INSERT INTO "+tableData[0]+"("  
       for values in tableData[1]:
              respuesta+="\n"+"\t"*(contador+1)+values.split()[0]+","
       respuesta=respuesta[0:-1]+"\n"+"\t"*(contador)+")\n"+"\t"*(contador)+"VALUES("
       for values in tableData[1]:
              respuesta+="\n"+"\t"*(contador+1)+"p"+values.split()[0][0].upper()+values.split()[0][1:]+","
       respuesta=respuesta[0:-1]+"\n"+"\t"*(contador)+");"

       if(flagNombre != []):
              while(contador>2):
                     
                     respuesta+="\n\n"+"\t"*(contador-1)+"END IF; \n\n"
                     contador-=1

       respuesta+="\n\tEND // \n\n"
       respuesta+="DELIMITER ; \n\n"
       #print(respuesta)
       return respuesta

#Testing functionality
#registerTable(getTableInfo(x))


def modifyTable(tableData):
       #print (tableData)
       substraction=[]
       for values in tableData[1]:
              if values not in tableData[3]:
                     substraction=substraction+[values]
       tableData[1]=tableData[3]+substraction
       respuesta= "\n\n\nDELIMITER //\n"
       respuesta+="/* --------------------------------------------------------------\n"
       respuesta+="\tCreado por:\tEduardo Andrés Chavarría Rey\n"
       respuesta+="\tFecha y Hora de Creación:\t"+str(datetime.datetime.now())[0:-7]+"\n"
       respuesta+="\tProcedimiento almacenado encargado de editar un registro en "+tableData[0]+"\n"
       respuesta+="   --------------------------------------------------------------\n"
       respuesta+="*/\n"
       respuesta+="CREATE PROCEDURE "+editionPrefixSP+tableData[0]+"("
       flagNombre=[]
       for values in tableData[1]:
              #print(values)
              respuesta+="\n\tp"+values[0].upper()+values[1:]+","
              if (values[0:6]=="nombre"):
                     flagNombre+=[values]
       respuesta=respuesta[0:-1]+"\n)\n"
       respuesta+="\tBEGIN\n"
       #for values in tableData[2]:
       if(flagNombre != []):
              for values in flagNombre:
                     respuesta+="\t\tDECLARE v"+values[0].upper()+values[1:]+";\n"
       respuesta+="\n\t\tDECLARE EXIT HANDLER FOR SQLEXCEPTION -- ERROR"
       respuesta+="\n\t\tBEGIN"
       respuesta+="\n\t\t\tSELECT -1;"
       respuesta+="\n\t\t\tRESIGNAL;"
       respuesta+="\n\t\t\tROLLBACK;"
       respuesta+="\n\t\tEND;\n\n"
       contador=2
       if(flagNombre != []):
              
              for values in flagNombre:
                     respuesta+="\t"*contador+"SELECT "+values.split()[0]+" FROM "+tableData[0]+"\n"
                     respuesta+="\t"*contador+"WHERE "+values.split()[0]+"="+"p"+values.split()[0][0].upper()+values.split()[0][1:]+"\n"

                     if(tableData[3]!=[]):
                            for values2 in tableData[3]:
                                   respuesta+="\t"*contador+"AND "+values2.split()[0]+"!="+"p"+values2.split()[0][0].upper()+values2.split()[0][1:]+"\n"
                     
                     respuesta+="\t"*contador+"LIMIT 1 INTO v"+values.split()[0][0].upper()+values.split()[0][1:]+";\n\n"
                     respuesta+="\t"*contador+"IF(v"+values.split()[0][0].upper()+values.split()[0][1:]+" IS NOT NULL)\n"
                     respuesta+="\t"*contador+"THEN\n\n"
                     respuesta+="\t"*(contador+1)+"SELECT "+str(-contador)+";\n\n"
                     respuesta+="\t"*contador+"ELSE \n\n"
                     contador+=1
                     
       respuesta+="\t"*(contador)+"UPDATE "+tableData[0]+"\n"+"\t"*(contador)+"SET"
       if(substraction!=[]):
              for values in substraction:
                     respuesta+="\n"+"\t"*(contador+1)+values.split()[0]+"=p"+values.split()[0][0].upper()+values.split()[0][1:]+","
              respuesta=respuesta[0:-1]+"\n"+"\t"*(contador)+"WHERE "+""+""
       else:
              return ""
       if(tableData[3]!=[]):
              for values2 in tableData[3]:
                     if values2==tableData[3][-1]:
                            respuesta+=values2.split()[0]+"="+"p"+values2.split()[0][0].upper()+values2.split()[0][1:]+";\n"
                     else:
                            respuesta+=values2.split()[0]+"="+"p"+values2.split()[0][0].upper()+values2.split()[0][1:]+"\n"+"\t"*contador+"AND "

       respuesta=respuesta+"\n"+"\t"*(contador)

       if(flagNombre != []):
              while(contador>2):
                     
                     respuesta+="\n\n"+"\t"*(contador-1)+"END IF; \n\n"
                     contador-=1

       respuesta+="\n\tEND // \n\n"
       respuesta+="DELIMITER ; \n\n"
              
              
       return respuesta


def enableTable(tableData):
       #print ("Enable",tableData)
       substraction=[]
       respuesta= "\n\n\nDELIMITER //\n"
       respuesta+="/* --------------------------------------------------------------\n"
       respuesta+="\tCreado por:\tEduardo Andrés Chavarría Rey\n"
       respuesta+="\tFecha y Hora de Creación:\t"+str(datetime.datetime.now())[0:-7]+"\n"
       respuesta+="\tProcedimiento almacenado encargado de habilitar un registro en "+tableData[0]+"\n"
       respuesta+="   --------------------------------------------------------------\n"
       respuesta+="*/\n"
       respuesta+="CREATE PROCEDURE "+enablePrefixSP+tableData[0]+"("
       for values in tableData[3]:
              #print(values)
              respuesta+="\n\tp"+values[0].upper()+values[1:]+","
       respuesta=respuesta[0:-1]+"\n)\n"
       respuesta+="\tBEGIN\n"
       #for values in tableData[2]:
       respuesta+="\n\t\tDECLARE EXIT HANDLER FOR SQLEXCEPTION -- ERROR"
       respuesta+="\n\t\tBEGIN"
       respuesta+="\n\t\t\tSELECT -1;"
       respuesta+="\n\t\t\tRESIGNAL;"
       respuesta+="\n\t\t\tROLLBACK;"
       respuesta+="\n\t\tEND;\n\n"
       contador=2
       
       respuesta+="\t"*(contador)+"UPDATE "+tableData[0]+"\n"+"\t"*(contador)+"SET"  
       respuesta+="\n"+"\t"*(contador+1)+enableColumn.split(" ")[0]+"=1"
       respuesta=respuesta+"\n"+"\t"*(contador)+"WHERE "+""+""
       if(tableData[3]!=[]):
              for values2 in tableData[3]:
                     if values2==tableData[3][-1]:
                            respuesta+=values2.split()[0]+"="+"p"+values2.split()[0][0].upper()+values2.split()[0][1:]+";\n"
                     else:
                            respuesta+=values2.split()[0]+"="+"p"+values2.split()[0][0].upper()+values2.split()[0][1:]+"\n"+"\t"*contador+"AND "
       
       respuesta+="\n\tEND // \n\n"
       respuesta+="DELIMITER ; \n\n"
              
              
       return respuesta

def disableTable(tableData):
       #print (tableData)
       substraction=[]
       respuesta= "\n\n\nDELIMITER //\n"
       respuesta+="/* --------------------------------------------------------------\n"
       respuesta+="\tCreado por:\tEduardo Andrés Chavarría Rey\n"
       respuesta+="\tFecha y Hora de Creación:\t"+str(datetime.datetime.now())[0:-7]+"\n"
       respuesta+="\tProcedimiento almacenado encargado de deshabilitar un registro en "+tableData[0]+"\n"
       respuesta+="   --------------------------------------------------------------\n"
       respuesta+="*/\n"
       respuesta+="CREATE PROCEDURE "+disablePrefixSP+tableData[0]+"("
       for values in tableData[3]:
              #print(values)
              respuesta+="\n\tp"+values[0].upper()+values[1:]+","
       respuesta=respuesta[0:-1]+"\n)\n"
       respuesta+="\tBEGIN\n"
       #for values in tableData[2]:
       respuesta+="\n\t\tDECLARE EXIT HANDLER FOR SQLEXCEPTION -- ERROR"
       respuesta+="\n\t\tBEGIN"
       respuesta+="\n\t\t\tSELECT -1;"
       respuesta+="\n\t\t\tRESIGNAL;"
       respuesta+="\n\t\t\tROLLBACK;"
       respuesta+="\n\t\tEND;\n\n"
       contador=2
       
       respuesta+="\t"*(contador)+"UPDATE "+tableData[0]+"\n"+"\t"*(contador)+"SET"  
       respuesta+="\n"+"\t"*(contador+1)+enableColumn.split(" ")[0]+"=0"
       respuesta=respuesta+"\n"+"\t"*(contador)+"WHERE "+""+""
       if(tableData[3]!=[]):
              for values2 in tableData[3]:
                     if values2==tableData[3][-1]:
                            respuesta+=values2.split()[0]+"="+"p"+values2.split()[0][0].upper()+values2.split()[0][1:]+";\n"
                     else:
                            respuesta+=values2.split()[0]+"="+"p"+values2.split()[0][0].upper()+values2.split()[0][1:]+"\n"+"\t"*contador+"AND "
       
       respuesta+="\n\tEND // \n\n"
       respuesta+="DELIMITER ; \n\n"
              
              
       return respuesta


def getTable(tableData):
       #print (tableData)
       substraction=[]
       respuesta= "\n\n\nDELIMITER //\n"
       respuesta+="/* --------------------------------------------------------------\n"
       respuesta+="\tCreado por:\tEduardo Andrés Chavarría Rey\n"
       respuesta+="\tFecha y Hora de Creación:\t"+str(datetime.datetime.now())[0:-7]+"\n"
       respuesta+="\tProcedimiento almacenado encargado de consultar todos los registros en la tabla "+tableData[0]+"\n"
       respuesta+="   --------------------------------------------------------------\n"
       respuesta+="*/\n"
       respuesta+="CREATE PROCEDURE "+getPrefixSP+tableData[0]+"( )\n"
       respuesta+="\tBEGIN\n"
       #for values in tableData[2]:
       respuesta+="\n\t\tDECLARE EXIT HANDLER FOR SQLEXCEPTION -- ERROR"
       respuesta+="\n\t\tBEGIN"
       respuesta+="\n\t\t\tSELECT -1;"
       respuesta+="\n\t\t\tRESIGNAL;"
       respuesta+="\n\t\t\tROLLBACK;"
       respuesta+="\n\t\tEND;\n\n"
       contador=2
       
       respuesta+="\t"*(contador)+"SELECT * FROM "+tableData[0]+";"
       
       respuesta+="\n\tEND // \n\n"
       respuesta+="DELIMITER ; \n\n"
              
       return respuesta


def getTableById(tableData):
       #print (tableData)
       substraction=[]
       respuesta= "\n\n\nDELIMITER //\n"
       respuesta+="/* --------------------------------------------------------------\n"
       respuesta+="\tCreado por:\tEduardo Andrés Chavarría Rey\n"
       respuesta+="\tFecha y Hora de Creación:\t"+str(datetime.datetime.now())[0:-7]+"\n"
       respuesta+="\tProcedimiento almacenado encargado de consultar un registro en "+tableData[0]+" basado en su(s) id(s)\n"
       respuesta+="   --------------------------------------------------------------\n"
       respuesta+="*/\n"
       respuesta+="CREATE PROCEDURE "+getPrefixSP+tableData[0]+byIdPrefixSP+"("
       for values in tableData[3]:
              #print(values)
              respuesta+="\n\tp"+values[0].upper()+values[1:]+","
       respuesta=respuesta[0:-1]+"\n)\n"
       respuesta+="\tBEGIN\n"
       #for values in tableData[2]:
       respuesta+="\n\t\tDECLARE EXIT HANDLER FOR SQLEXCEPTION -- ERROR"
       respuesta+="\n\t\tBEGIN"
       respuesta+="\n\t\t\tSELECT -1;"
       respuesta+="\n\t\t\tRESIGNAL;"
       respuesta+="\n\t\t\tROLLBACK;"
       respuesta+="\n\t\tEND;\n\n"
       contador=2
       
       respuesta+="\t"*(contador)+"SELECT * FROM "+tableData[0]
       respuesta=respuesta+"\n"+"\t"*(contador)+"WHERE "+""+""
       if(tableData[3]!=[]):
              for values2 in tableData[3]:
                     if values2==tableData[3][-1]:
                            respuesta+=values2.split()[0]+"="+"p"+values2.split()[0][0].upper()+values2.split()[0][1:]+";\n"
                     else:
                            respuesta+=values2.split()[0]+"="+"p"+values2.split()[0][0].upper()+values2.split()[0][1:]+"\n"+"\t"*contador+"AND "
       
       respuesta+="\n\tEND // \n\n"
       respuesta+="DELIMITER ; \n\n"
              
       return respuesta

def getTableByEnabled(tableData):
       #print (tableData)
       substraction=[]
       respuesta= "\n\n\nDELIMITER //\n"
       respuesta+="/* --------------------------------------------------------------\n"
       respuesta+="\tCreado por:\tEduardo Andrés Chavarría Rey\n"
       respuesta+="\tFecha y Hora de Creación:\t"+str(datetime.datetime.now())[0:-7]+"\n"
       respuesta+="\tProcedimiento almacenado encargado de consultar todos los registros habilitados en la tabla "+tableData[0]+"\n"
       respuesta+="   --------------------------------------------------------------\n"
       respuesta+="*/\n"
       respuesta+="CREATE PROCEDURE "+getPrefixSP+tableData[0]+getEnabledSufixSP+"( )\n"
       respuesta+="\tBEGIN\n"
       #for values in tableData[2]:
       respuesta+="\n\t\tDECLARE EXIT HANDLER FOR SQLEXCEPTION -- ERROR"
       respuesta+="\n\t\tBEGIN"
       respuesta+="\n\t\t\tSELECT -1;"
       respuesta+="\n\t\t\tRESIGNAL;"
       respuesta+="\n\t\t\tROLLBACK;"
       respuesta+="\n\t\tEND;\n\n"
       contador=2
       
       respuesta+="\t"*(contador)+"SELECT * FROM "+tableData[0]
       respuesta+="\n"+"\t"*(contador)+"WHERE "+enableColumn.split(" ")[0]+"= 1;"
       
       respuesta+="\n\tEND // \n\n"
       respuesta+="DELIMITER ; \n\n"
              
       return respuesta

def getTableByDisabled(tableData):
       #print (tableData)
       substraction=[]
       respuesta= "\n\n\nDELIMITER //\n"
       respuesta+="/* --------------------------------------------------------------\n"
       respuesta+="\tCreado por:\tEduardo Andrés Chavarría Rey\n"
       respuesta+="\tFecha y Hora de Creación:\t"+str(datetime.datetime.now())[0:-7]+"\n"
       respuesta+="\tProcedimiento almacenado encargado de consultar todos los registros deshabilitados en la tabla "+tableData[0]+"\n"
       respuesta+="   --------------------------------------------------------------\n"
       respuesta+="*/\n"
       respuesta+="CREATE PROCEDURE "+getPrefixSP+tableData[0]+getDisabledSufixSP+"( )\n"
       respuesta+="\tBEGIN\n"
       #for values in tableData[2]:
       respuesta+="\n\t\tDECLARE EXIT HANDLER FOR SQLEXCEPTION -- ERROR"
       respuesta+="\n\t\tBEGIN"
       respuesta+="\n\t\t\tSELECT -1;"
       respuesta+="\n\t\t\tRESIGNAL;"
       respuesta+="\n\t\t\tROLLBACK;"
       respuesta+="\n\t\tEND;\n\n"
       contador=2
       
       respuesta+="\t"*(contador)+"SELECT * FROM "+tableData[0]
       respuesta+="\n"+"\t"*(contador)+"WHERE "+enableColumn.split(" ")[0]+"= 0;"
       
       respuesta+="\n\tEND // \n\n"
       respuesta+="DELIMITER ; \n\n"
              
       return respuesta

#### Proof of Concept of a Combinatory algorithm.
xx=[1,2,3,4]
def combinatory(lista, fijas=[], variables=[], contador=0, deepness=0):
       print ("\n\nContador="+str(contador)+ "| Deepness="+str(deepness))
       print("Lista :"+str(lista)+"\nFijas"+str(fijas)+"\nVariables"+str(variables))
       if(len(variables)==1):
              print(fijas)
              print(fijas+variables)
       else:
              combinatory([], fijas , variables[1:], contador+1, deepness)
              combinatory([], fijas + [variables[0]] , variables[1:], contador+1, deepness)
       if(lista!=[]):
              combinatory(lista[:-1],[lista[-1]],fijas+variables, contador+1, deepness+1)

#### Start Point.
def combinatory1(lista):
       if(lista!=[]):
              combinatory(lista[:-1], [], [lista[-1]])

#### Test
#combinatory1(xx)


#### Uses getTableInfo output, to generate all posible optional column's combinations and calls registerTable. 
def combinatoryTableInfo(tableData, lista, fijas=[], variables=[], contador=0, deepness=0):
       #print ("\n\nContador="+str(contador)+ "| Deepness="+str(deepness))
       #print("Lista :"+str(lista)+"\nFijas"+str(fijas)+"\nVariables"+str(variables))
       if(len(variables)==1):
              f=open(os.getcwd()+"\\"+projectName+"\\"+str(fileCounter)+". SP_"+tableData[0]+".sql","a")
              f.write(registerTable([tableData[0]]+[tableData[1]+fijas]))
              f.close()
              f=open(os.getcwd()+"\\"+projectName+"\\"+str(fileCounter)+". SP_"+tableData[0]+".sql","a")
              f.write(modifyTable([tableData[0]]+[tableData[1]+fijas]+[[]]+[tableData[3]]))
              f.close()
              f=open(os.getcwd()+"\\"+projectName+"\\"+str(fileCounter)+". SP_"+tableData[0]+".sql","a")
              f.write(registerTable([tableData[0]]+[tableData[1]+fijas+variables]))
              f.close()
              f=open(os.getcwd()+"\\"+projectName+"\\"+str(fileCounter)+". SP_"+tableData[0]+".sql","a")
              f.write(modifyTable([tableData[0]]+[tableData[1]+fijas+variables]+[[]]+[tableData[3]]))
              f.close()
       else:
              combinatoryTableInfo(tableData,[], fijas , variables[1:], contador+1, deepness)
              combinatoryTableInfo(tableData,[], fijas + [variables[0]] , variables[1:], contador+1, deepness)
       if(lista!=[]):
              combinatoryTableInfo(tableData,lista[:-1],[lista[-1]],fijas+variables, contador+1, deepness+1)


def combinatoryTableInfoStart(tableData):
       #print(tableData)
       f=open(os.getcwd()+"\\"+projectName+"\\"+str(fileCounter)+". SP_"+tableData[0]+".sql","x")
       f.close()
       f=open(os.getcwd()+"\\"+projectName+"\\"+str(fileCounter)+". SP_"+tableData[0]+".sql","a")
       f.write("\n\n\n ############## PROCEDIMIENTOS ALMACENADOS DE LA TABLA "+tableData[0].upper()+" ###############")
       if(tableData!=[]):
              if(tableData[2]!=[]):
                     f.close()
                     combinatoryTableInfo(tableData, tableData[2][:-1], [], [tableData[2][-1]])
              else:
                     f.write(registerTable(tableData))
                     f.close()
                     f=open(os.getcwd()+"\\"+projectName+"\\"+str(fileCounter)+". SP_"+tableData[0]+".sql","a")
                     f.write(modifyTable(tableData))
                     f.close()

# Test
#combinatoryTableInfoStart(getTableInfo(y))


# Delete the directory for the stored procedures on a Database
def createDirectory():
       #print (len(os.listdir(os.getcwd())))
       path = os.getcwd()+"\\"+projectName
       if os.path.isdir(path):
              shutil.rmtree(path)
       try:  
              os.mkdir(path)
       except OSError:  
              print ("Creation of the directory %s failed" % path)
       else:  
              print ("Successfully created the directory %s " % path)

def processDataBaseFile():
       createDirectory()
       global fileCounter
       f=open(dataBaseFileLocation,"r")
       data=f.read().split("USE `"+dataBaseName+"` ;")
       data=data[1].split("\n\n-- -----------------------------------------------------")[1:]
       for values in data:
              print(getTableInfo(values))
              print()
              print()
              tableData = getTableInfo(values)
              if tableData!=[]:
                     if enableColumn in tableData[1]:
                            f=open(os.getcwd()+"\\"+projectName+"\\"+str(fileCounter)+". SP_"+tableData[0]+".sql","a")
                            f.write(registerTable([tableData[0]]+[tableData[1]+tableData[2]]+[[]]+[tableData[3]]))
                            f.write(modifyTable([tableData[0]]+[tableData[1]+tableData[2]]+[[]]+[tableData[3]]))
                            f.write(enableTable([tableData[0]]+[tableData[1]+tableData[2]]+[[]]+[tableData[3]]))
                            f.write(disableTable([tableData[0]]+[tableData[1]+tableData[2]]+[[]]+[tableData[3]]))
                            f.write(getTable([tableData[0]]+[tableData[1]+tableData[2]]+[[]]+[tableData[3]]))
                            f.write(getTableById([tableData[0]]+[tableData[1]+tableData[2]]+[[]]+[tableData[3]]))
                            f.write(getTableByEnabled([tableData[0]]+[tableData[1]+tableData[2]]+[[]]+[tableData[3]]))
                            f.write(getTableByDisabled([tableData[0]]+[tableData[1]+tableData[2]]+[[]]+[tableData[3]]))
                            f.close()
                     else:
                            f=open(os.getcwd()+"\\"+projectName+"\\"+str(fileCounter)+". SP_"+tableData[0]+".sql","a")
                            f.write(registerTable([tableData[0]]+[tableData[1]+tableData[2]]+[[]]+[tableData[3]]))
                            f.write(modifyTable([tableData[0]]+[tableData[1]+tableData[2]]+[[]]+[tableData[3]]))
                            f.write(getTable([tableData[0]]+[tableData[1]+tableData[2]]+[[]]+[tableData[3]]))
                            f.write(getTableById([tableData[0]]+[tableData[1]+tableData[2]]+[[]]+[tableData[3]]))
                            f.close()
                            
                     fileCounter=fileCounter+1

processDataBaseFile()
#print(registerTable(getTableInfo(x)))
#print(modifyTable(getTableInfo(x)))
#printTableInfo(getTableInfo(hh))

