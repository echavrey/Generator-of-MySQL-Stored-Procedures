# Programa "compilador" para generar Stored Procedures a partir de las tablas de una Base de Datos

import datetime
import os
import shutil

# Change it base on the name of the project
projectName= "MyProject"
fileCounter=1
dataBaseFileLocation= "C:\\Users\\MyUserName\\Documents\\blablabla.sql"
dataBaseName= "MyDB"


####################################################################################################################################################### 
# 0 variables opcinales
z="\n-- -----------------------------------------------------\n-- Table `ADADB`.`Habilidad`\n-- -----------------------------------------------------\nCREATE TABLE IF NOT EXISTS `ADADB`.`Habilidad` (\n  `idHabilidad` MEDIUMINT UNSIGNED NOT NULL AUTO_INCREMENT,\n  `idCategoriaHabilidad` SMALLINT UNSIGNED NOT NULL,\n  `nombreHabilidad` NVARCHAR(45) NOT NULL,\n  `descripcionHabilidad` NVARCHAR(450) NOT NULL,\n  PRIMARY KEY (`idHabilidad`, `idCategoriaHabilidad`),\n  INDEX `fk_Habilidad_CategoriaHabilidad1_idx` (`idCategoriaHabilidad` ASC),\n  UNIQUE INDEX `idHabilidad_UNIQUE` (`idHabilidad` ASC),\n  CONSTRAINT `fk_Habilidad_CategoriaHabilidad1`\n    FOREIGN KEY (`idCategoriaHabilidad`)\n    REFERENCES `ADADB`.`CategoriaHabilidad` (`idCategoriaHabilidad`)\n    ON DELETE NO ACTION\n    ON UPDATE NO ACTION)\nENGINE = InnoDB;"

# Input: Todo el código de una tabla MySQL generada con el Workbench | All the code of a table on mySQL generated by Workbench.

def getTableInfo(code):
       respuesta=[]
       omitir=["PRIMARY","INDEX","UNIQUE","CONSTRAINT","FOREIGN",
               "REFERENCES","ON","ENGINE", "--"]
       omitir2=["NOT","NULL","NULL,"]
       lines= code.split("\n")
       for line in lines:
              lineTemp = line
              line=line.split()
              fase=0
              omit=False
              columnaDato=""
              notNull=False
              for element in line: 
                     if(element in omitir):
                            break
                     elif(element=="CREATE"):
                            omit = True
                     elif(element[0:9] == "`ADADB`.`" and omit==True):
                            respuesta=respuesta+[element[9:-1]]
                            respuesta = respuesta + [[]] + [[]]
                            #print (respuesta)
                            omit=False
                            break
                     elif(omit):
                            continue
                     else:
                            #print("LINEA \t: "+str(line))
                            #print("ELEMENT \t: "+str(element))
                            #print("ColumnaDato \t: "+str(columnaDato))
                            #print("Respuesta \t: "+str(respuesta))
                            #print()
                            if(fase>0 and line[-1]==element and element=="AUTO_INCREMENT,"):
                                   columnaDato=""
                                   fase=0
                                   break
                            elif(fase==0):
                                   columnaDato=element[1:-1]
                                   fase+=1
                            elif(fase>0 and line[-1]!=element):
                                   if element not in omitir2:
                                          columnaDato=columnaDato+" "+element
                                   else:
                                          notNull=True
                            else:
                                   if (element not in omitir2):
                                          columnaDato=columnaDato+" "+element
                                   if(notNull):
                                          respuesta[1]=respuesta[1]+[columnaDato]
                                   else:
                                          respuesta[2]=respuesta[2]+[columnaDato]
       return(respuesta)


# Display's getTableInfo nicely. 
def printTableInfo(resultado):
       print("Nombre de la Tabla: "+resultado[0])
       print("Columnas Fijas: ")
       for values in resultado[1]:
              print("\t"+str(values))
       print("Columnas Opcionales: ")
       for values in resultado[2]:
              print("\t"+str(values))
       
# Create a Register stored procedure, based on the output of getTableInfo
def registerTable(tableData):
       #print (tableData)
       respuesta= "\n\n\n DELIMINER //\n"
       respuesta+="/* --------------------------------------------------------------\n"
       respuesta+="\tCreado por:\tEduardo Andrés Chavarría Rey\n"
       respuesta+="\tFecha y Hora de Creación:\t"+str(datetime.datetime.now())[0:-7]+"\n"
       respuesta+="\tProcedimiento almacenado encargado de insertar un registro en "+tableData[0]+"\n"
       respuesta+="   --------------------------------------------------------------\n"
       respuesta+="*/\n"
       respuesta+="CREATE PROCEDURE MSP_Registrar"+tableData[0]+"("
       flagNombre=[]
       for values in tableData[1]:
              #print(values)
              respuesta+="\n\tp"+values[0].upper()+values[1:]+","
              if (values[0:6]=="nombre"):
                     flagNombre+=[values]
       respuesta=respuesta[0:-1]+"\n)\n"
       respuesta+="\tBEGIN\n"
       #for values in tableData[2]:
       if(flagNombre != []):
              for values in flagNombre:
                     respuesta+="\t\tDECLARE v"+values[0].upper()+values[1:]+";\n"
       respuesta+="\n\t\tDECLARE EXIT HANDLER FOR SQLEXCEPTION -- ERROR"
       respuesta+="\n\t\tBEGIN"
       respuesta+="\n\t\t\tSELECT -1;"
       respuesta+="\n\t\t\tRESIGNAL;"
       respuesta+="\n\t\t\tROLLBACK;"
       respuesta+="\n\t\tEND\n\n"
       contador=2
       if(flagNombre != []):
              
              for values in flagNombre:
                     respuesta+="\t"*contador+"SELECT "+values.split()[0]+" FROM "+tableData[0]+"\n"
                     respuesta+="\t"*contador+"WHERE "+values.split()[0]+"="+"p"+values.split()[0][0].upper()+values.split()[0][1:]+"\n"
                     respuesta+="\t"*contador+"LIMIT 1 INTO v"+values.split()[0][0].upper()+values.split()[0][1:]+"\n\n"
                     respuesta+="\t"*contador+"IF(v"+values.split()[0][0].upper()+values.split()[0][1:]+" IS NOT NULL)\n"
                     respuesta+="\t"*contador+"THEN\n\n"
                     respuesta+="\t"*(contador+1)+"SELECT "+str(-contador)+";\n\n"
                     respuesta+="\t"*contador+"ELSE \n\n"
                     contador+=1
                     
       respuesta+="\t"*(contador)+"INSERT INTO "+tableData[0]+"("  
       for values in tableData[1]:
              respuesta+="\n"+"\t"*(contador+1)+values.split()[0]+","
       respuesta=respuesta[0:-1]+"\n"+"\t"*(contador)+")\n"+"\t"*(contador)+"VALUES("
       for values in tableData[1]:
              respuesta+="\n"+"\t"*(contador+1)+"p"+values.split()[0][0].upper()+values.split()[0][1:]+","
       respuesta=respuesta[0:-1]+"\n"+"\t"*(contador)+");"

       if(flagNombre != []):
              while(contador>2):
                     
                     respuesta+="\n\n"+"\t"*(contador-1)+"END IF; \n\n"
                     contador-=1

       respuesta+="END// \n\n"
       respuesta+="DELIMITER; \n\n"
       #print(respuesta)
       return respuesta

#Testing functionality
#registerTable(getTableInfo(x))


#### Proof of Concept of a Combinatory algorithm.
xx=[1,2,3,4]
def combinatory(lista, fijas=[], variables=[], contador=0, deepness=0):
       print ("\n\nContador="+str(contador)+ "| Deepness="+str(deepness))
       print("Lista :"+str(lista)+"\nFijas"+str(fijas)+"\nVariables"+str(variables))
       if(len(variables)==1):
              print(fijas)
              print(fijas+variables)
       else:
              combinatory([], fijas , variables[1:], contador+1, deepness)
              combinatory([], fijas + [variables[0]] , variables[1:], contador+1, deepness)
       if(lista!=[]):
              combinatory(lista[:-1],[lista[-1]],fijas+variables, contador+1, deepness+1)

#### Start Point.
def combinatory1(lista):
       if(lista!=[]):
              combinatory(lista[:-1], [], [lista[-1]])

#### Test
#combinatory1(xx)


#### Uses getTableInfo output, to generate all posible optional column's combinations and calls registerTable. 
def combinatoryTableInfo(tableData, lista, fijas=[], variables=[], contador=0, deepness=0):
       #print ("\n\nContador="+str(contador)+ "| Deepness="+str(deepness))
       #print("Lista :"+str(lista)+"\nFijas"+str(fijas)+"\nVariables"+str(variables))
       if(len(variables)==1):
              f=open(os.getcwd()+"\\"+projectName+"\\"+str(fileCounter)+". SP_"+tableData[0]+".sql","a")
              f.write(registerTable([tableData[0]]+[tableData[1]+fijas]))
              f.close()
              f=open(os.getcwd()+"\\"+projectName+"\\"+str(fileCounter)+". SP_"+tableData[0]+".sql","a")
              f.write(registerTable([tableData[0]]+[tableData[1]+fijas+variables]))
       else:
              combinatoryTableInfo(tableData,[], fijas , variables[1:], contador+1, deepness)
              combinatoryTableInfo(tableData,[], fijas + [variables[0]] , variables[1:], contador+1, deepness)
       if(lista!=[]):
              combinatoryTableInfo(tableData,lista[:-1],[lista[-1]],fijas+variables, contador+1, deepness+1)


def combinatoryTableInfoStart(tableData):
       f=open(os.getcwd()+"\\"+projectName+"\\"+str(fileCounter)+". SP_"+tableData[0]+".sql","x")
       f.close()
       f=open(os.getcwd()+"\\"+projectName+"\\"+str(fileCounter)+". SP_"+tableData[0]+".sql","a")
       f.write("\n\n\n ############## STORED PROCEDURES OF TABLE "+tableData[0].upper()+" ###############")
       if(tableData!=[]):
              if(tableData[2]!=[]):
                     f.close()
                     combinatoryTableInfo(tableData, tableData[2][:-1], [], [tableData[2][-1]])
              else:
                     f.write(registerTable(tableData))
                     f.close()

# Test
#combinatoryTableInfoStart(getTableInfo(y))


# Delete the directory for the stored procedures on a Database
def createDirectory():
       #print (len(os.listdir(os.getcwd())))
       path = os.getcwd()+"\\"+projectName
       if os.path.isdir(path):
              shutil.rmtree(path)
       try:  
              os.mkdir(path)
       except OSError:  
              print ("Creation of the directory %s failed" % path)
       else:  
              print ("Successfully created the directory %s " % path)

def processDataBaseFile():
       createDirectory()
       global fileCounter
       f=open(dataBaseFileLocation,"r")
       data=f.read().split("USE `"+dataBaseName+"` ;")
       data=data[1].split("\n\n-- -----------------------------------------------------")[1:]
       for values in data:
              combinatoryTableInfoStart(getTableInfo(values))
              fileCounter=fileCounter+1

processDataBaseFile()








